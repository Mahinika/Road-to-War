<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Animation Debugger - Road of War</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a1a1a;
            color: #e0e0e0;
            padding: 20px;
        }

        .header {
            background: #2d2d2d;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        h1 {
            color: #4CAF50;
            margin-bottom: 10px;
        }

        .controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-top: 15px;
        }

        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.3s;
        }

        button:hover {
            background: #45a049;
        }

        button:disabled {
            background: #555;
            cursor: not-allowed;
        }

        select, input {
            background: #333;
            color: #e0e0e0;
            border: 1px solid #555;
            padding: 8px;
            border-radius: 4px;
            font-size: 14px;
        }

        .main-container {
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 20px;
        }

        .sidebar {
            background: #2d2d2d;
            padding: 20px;
            border-radius: 8px;
            height: fit-content;
        }

        .sidebar h2 {
            color: #4CAF50;
            margin-bottom: 15px;
            font-size: 18px;
        }

        .sidebar-section {
            margin-bottom: 20px;
        }

        .sidebar-section label {
            display: block;
            margin-bottom: 5px;
            color: #bbb;
            font-size: 12px;
        }

        .content-area {
            background: #2d2d2d;
            padding: 20px;
            border-radius: 8px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .stat-card {
            background: #333;
            padding: 15px;
            border-radius: 6px;
            border-left: 4px solid #4CAF50;
        }

        .stat-label {
            color: #bbb;
            font-size: 12px;
            margin-bottom: 5px;
        }

        .stat-value {
            color: #4CAF50;
            font-size: 24px;
            font-weight: bold;
        }

        .frames-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
            gap: 10px;
            margin-top: 20px;
        }

        .frame-item {
            background: #333;
            border: 2px solid #555;
            border-radius: 6px;
            padding: 10px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
        }

        .frame-item:hover {
            border-color: #4CAF50;
            transform: scale(1.05);
        }

        .frame-item.selected {
            border-color: #4CAF50;
            background: #2a4a2a;
        }

        .frame-item.invalid {
            border-color: #f44336;
            background: #4a2a2a;
        }

        .frame-preview {
            width: 100%;
            height: 120px;
            background: #1a1a1a;
            border: 1px solid #555;
            border-radius: 4px;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #666;
            font-size: 12px;
        }

        .frame-preview img {
            max-width: 100%;
            max-height: 100%;
            image-rendering: pixelated;
        }

        .frame-info {
            font-size: 11px;
            color: #bbb;
        }

        .frame-details {
            background: #333;
            padding: 15px;
            border-radius: 6px;
            margin-top: 20px;
        }

        .frame-details h3 {
            color: #4CAF50;
            margin-bottom: 10px;
        }

        .detail-row {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #444;
        }

        .detail-row:last-child {
            border-bottom: none;
        }

        .detail-label {
            color: #bbb;
        }

        .detail-value {
            color: #e0e0e0;
        }

        .error-list {
            background: #4a2a2a;
            border: 1px solid #f44336;
            border-radius: 6px;
            padding: 15px;
            margin-top: 20px;
        }

        .error-list h3 {
            color: #f44336;
            margin-bottom: 10px;
        }

        .error-item {
            color: #ffaaaa;
            margin: 5px 0;
            padding-left: 20px;
            font-size: 13px;
        }

        .warning-list {
            background: #4a4a2a;
            border: 1px solid #ffaa00;
            border-radius: 6px;
            padding: 15px;
            margin-top: 20px;
        }

        .warning-list h3 {
            color: #ffaa00;
            margin-bottom: 10px;
        }

        .warning-item {
            color: #ffdd88;
            margin: 5px 0;
            padding-left: 20px;
            font-size: 13px;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #666;
        }

        .connection-status {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .connection-status.connected {
            background: #4CAF50;
        }

        .connection-status.disconnected {
            background: #f44336;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üé¨ Animation Debugger</h1>
        <div>
            <span class="connection-status" id="connectionStatus"></span>
            <span id="connectionText">Connecting to game...</span>
            <div style="font-size: 11px; color: #888; margin-top: 4px;">
                ‚ö†Ô∏è Make sure you're on the same port as the game (http://localhost:3000)
            </div>
        </div>
        <div class="controls">
            <button id="refreshBtn">üîÑ Refresh</button>
            <button id="inspectBtn">üîç Inspect Selected</button>
            <button id="exportBtn">üíæ Export Data</button>
            <select id="characterTypeSelect">
                <option value="">Select Character Type...</option>
            </select>
            <select id="animationSelect">
                <option value="">Select Animation...</option>
            </select>
        </div>
    </div>

    <div class="main-container">
        <div class="sidebar">
            <h2>Statistics</h2>
            <div class="stats-grid" id="statsGrid">
                <div class="stat-card">
                    <div class="stat-label">Total Animations</div>
                    <div class="stat-value" id="totalAnimations">-</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Total Frames</div>
                    <div class="stat-value" id="totalFrames">-</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Memory Estimate</div>
                    <div class="stat-value" id="memoryEstimate">-</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Valid Frames</div>
                    <div class="stat-value" id="validFrames">-</div>
                </div>
            </div>

            <div class="sidebar-section">
                <h2>Animation List</h2>
                <div id="animationList"></div>
            </div>
        </div>

        <div class="content-area">
            <div id="framesContainer">
                <div class="loading">Select an animation to view frames</div>
            </div>

            <div id="frameDetails" style="display: none;">
                <div class="frame-details">
                    <h3>Frame Details</h3>
                    <div id="frameDetailsContent"></div>
                </div>
            </div>

            <div id="errorsContainer" style="display: none;"></div>
            <div id="warningsContainer" style="display: none;"></div>
        </div>
    </div>

    <script>
        // Connection to game
        let gameScene = null;
        let currentAnimation = null;
        let selectedFrame = null;

        // Check for game connection
        function checkConnection() {
            // Try multiple ways to access the game
            let scene = null;
            
            // Method 1: Direct window access (same origin)
            if (window.game && window.gameScene) {
                scene = window.gameScene;
            }
            // Method 2: Try to get scene from game instance
            else if (window.game && window.game.scene) {
                scene = window.game.scene.getScene('GameScene');
                if (scene) {
                    window.gameScene = scene; // Cache it
                }
            }
            // Method 3: Try parent window (if in iframe)
            else if (window.parent && window.parent !== window) {
                if (window.parent.game && window.parent.gameScene) {
                    scene = window.parent.gameScene;
                } else if (window.parent.game && window.parent.game.scene) {
                    scene = window.parent.game.scene.getScene('GameScene');
                }
            }
            
            if (scene && scene.animationManager) {
                gameScene = scene;
                document.getElementById('connectionStatus').className = 'connection-status connected';
                document.getElementById('connectionText').textContent = 'Connected to game';
                loadStatistics();
                loadCharacterTypes();
                return true;
            } else {
                document.getElementById('connectionStatus').className = 'connection-status disconnected';
                let msg = 'Not connected - ';
                if (!window.game) {
                    msg += 'Game not found. ';
                } else if (!scene) {
                    msg += 'GameScene not found. ';
                } else {
                    msg += 'AnimationManager not available. ';
                }
                msg += 'Make sure the game is running and GameScene is loaded.';
                document.getElementById('connectionText').textContent = msg;
                return false;
            }
        }

        // Load statistics
        function loadStatistics() {
            if (!gameScene || !gameScene.animationManager) return;

            try {
                const stats = gameScene.animationManager.getPerformanceMetrics();
                document.getElementById('totalAnimations').textContent = stats.registeredAnimationCount || 0;
                document.getElementById('totalFrames').textContent = stats.totalFrames || 0;
                document.getElementById('memoryEstimate').textContent = (stats.memoryEstimate / 1024 / 1024).toFixed(2) + ' MB';
            } catch (error) {
                console.error('Error loading statistics:', error);
            }
        }

        // Load character types
        function loadCharacterTypes() {
            if (!gameScene || !gameScene.anims) return;

            const select = document.getElementById('characterTypeSelect');
            const types = new Set();

            for (const key of Object.keys(gameScene.anims.anims.entries)) {
                const parts = key.split('-');
                if (parts.length >= 2) {
                    types.add(parts[0]);
                }
            }

            select.innerHTML = '<option value="">Select Character Type...</option>';
            for (const type of Array.from(types).sort()) {
                const option = document.createElement('option');
                option.value = type;
                option.textContent = type;
                select.appendChild(option);
            }
        }

        // Load animations for character type
        function loadAnimations(characterType) {
            if (!gameScene || !gameScene.anims || !characterType) return;

            const select = document.getElementById('animationSelect');
            select.innerHTML = '<option value="">Select Animation...</option>';

            const animations = [];
            for (const key of Object.keys(gameScene.anims.anims.entries)) {
                if (key.startsWith(`${characterType}-`)) {
                    animations.push(key);
                }
            }

            for (const animKey of animations.sort()) {
                const option = document.createElement('option');
                option.value = animKey;
                option.textContent = animKey;
                select.appendChild(option);
            }
        }

        // Load animation frames
        async function loadAnimationFrames(animKey) {
            if (!gameScene || !gameScene.anims || !gameScene.anims.exists(animKey)) {
                document.getElementById('framesContainer').innerHTML = '<div class="loading">Animation not found</div>';
                return;
            }

            currentAnimation = animKey;
            const anim = gameScene.anims.get(animKey);
            const container = document.getElementById('framesContainer');

            if (!anim || !anim.frames) {
                container.innerHTML = '<div class="loading">No frames found</div>';
                return;
            }

            container.innerHTML = '<div class="loading">Loading frames...</div>';

            // Use animation debugger if available
            let frames = [];
            if (gameScene.animationManager && gameScene.animationManager.debugger) {
                const inspection = gameScene.animationManager.debugger.inspectAnimation(animKey);
                frames = inspection.frames || [];
            } else {
                // Fallback: create frame info from animation
                for (let i = 0; i < anim.frames.length; i++) {
                    const frame = anim.frames[i];
                    frames.push({
                        index: i,
                        textureKey: frame.textureKey || frame.key || 'unknown',
                        valid: true
                    });
                }
            }

            // Display frames
            const grid = document.createElement('div');
            grid.className = 'frames-grid';

            for (const frame of frames) {
                const frameItem = document.createElement('div');
                frameItem.className = 'frame-item' + (frame.valid ? '' : ' invalid');
                frameItem.onclick = () => selectFrame(frame);

                const preview = document.createElement('div');
                preview.className = 'frame-preview';
                
                // Try to get texture image
                if (gameScene.textures.exists(frame.textureKey)) {
                    const texture = gameScene.textures.get(frame.textureKey);
                    if (texture && texture.source && texture.source[0]) {
                        const source = texture.source[0];
                        const img = source.image || source.canvas;
                        if (img) {
                            const imgEl = document.createElement('img');
                            imgEl.src = img.src || (img.toDataURL ? img.toDataURL() : '');
                            preview.appendChild(imgEl);
                        } else {
                            preview.textContent = 'Frame ' + frame.index;
                        }
                    } else {
                        preview.textContent = 'Frame ' + frame.index;
                    }
                } else {
                    preview.textContent = 'Missing';
                }

                const info = document.createElement('div');
                info.className = 'frame-info';
                info.textContent = `Frame ${frame.index}`;

                frameItem.appendChild(preview);
                frameItem.appendChild(info);
                grid.appendChild(frameItem);
            }

            container.innerHTML = '';
            container.appendChild(grid);

            // Show errors/warnings if any
            if (frames.some(f => !f.valid)) {
                showErrors(frames.filter(f => !f.valid));
            }
        }

        // Select frame
        function selectFrame(frame) {
            selectedFrame = frame;
            
            // Update UI
            document.querySelectorAll('.frame-item').forEach(item => {
                item.classList.remove('selected');
            });
            event.currentTarget.classList.add('selected');

            // Show frame details
            showFrameDetails(frame);
        }

        // Show frame details
        function showFrameDetails(frame) {
            const container = document.getElementById('frameDetails');
            const content = document.getElementById('frameDetailsContent');
            
            container.style.display = 'block';
            content.innerHTML = `
                <div class="detail-row">
                    <span class="detail-label">Index:</span>
                    <span class="detail-value">${frame.index}</span>
                </div>
                <div class="detail-row">
                    <span class="detail-label">Texture Key:</span>
                    <span class="detail-value">${frame.textureKey}</span>
                </div>
                <div class="detail-row">
                    <span class="detail-label">Valid:</span>
                    <span class="detail-value">${frame.valid ? 'Yes' : 'No'}</span>
                </div>
                ${frame.info ? Object.entries(frame.info).map(([key, value]) => `
                    <div class="detail-row">
                        <span class="detail-label">${key}:</span>
                        <span class="detail-value">${value}</span>
                    </div>
                `).join('') : ''}
            `;
        }

        // Show errors
        function showErrors(invalidFrames) {
            const container = document.getElementById('errorsContainer');
            container.style.display = 'block';
            container.innerHTML = `
                <div class="error-list">
                    <h3>Errors (${invalidFrames.length})</h3>
                    ${invalidFrames.map(f => `
                        <div class="error-item">Frame ${f.index}: ${f.errors ? f.errors.join(', ') : 'Invalid'}</div>
                    `).join('')}
                </div>
            `;
        }

        // Event listeners
        document.getElementById('refreshBtn').onclick = () => {
            checkConnection();
            if (currentAnimation) {
                loadAnimationFrames(currentAnimation);
            }
        };

        document.getElementById('characterTypeSelect').onchange = (e) => {
            loadAnimations(e.target.value);
        };

        document.getElementById('animationSelect').onchange = (e) => {
            if (e.target.value) {
                loadAnimationFrames(e.target.value);
            }
        };

        document.getElementById('inspectBtn').onclick = () => {
            if (currentAnimation && gameScene && gameScene.animationManager && gameScene.animationManager.debugger) {
                gameScene.animationManager.debugger.logAnimationInfo(currentAnimation);
                alert('Animation info logged to console');
            }
        };

        document.getElementById('exportBtn').onclick = () => {
            if (currentAnimation && gameScene && gameScene.animationManager && gameScene.animationManager.debugger) {
                const data = gameScene.animationManager.debugger.exportAnimationData(currentAnimation);
                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `animation-${currentAnimation}-${Date.now()}.json`;
                a.click();
            }
        };

        // Initial connection check
        checkConnection();
        
        // More aggressive connection retry
        let retryCount = 0;
        const maxRetries = 30; // Try for 60 seconds
        
        const connectionInterval = setInterval(() => {
            if (checkConnection()) {
                clearInterval(connectionInterval);
            } else {
                retryCount++;
                if (retryCount >= maxRetries) {
                    clearInterval(connectionInterval);
                    document.getElementById('connectionText').textContent = 
                        'Connection failed. Try: 1) Refresh game page, 2) Open http://localhost:3000/animation-debugger.html, 3) Use console: paste inject-animation-debugger.js';
                }
            }
        }, 2000);
        
        // Also try to inject debugger script if available
        if (window.game && window.gameScene) {
            const script = document.createElement('script');
            script.src = '/inject-animation-debugger.js';
            script.onload = () => {
                console.log('Animation debugger script loaded');
            };
            document.head.appendChild(script);
        }
    </script>
</body>
</html>

