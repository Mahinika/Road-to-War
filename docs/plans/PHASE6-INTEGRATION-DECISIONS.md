# Phase 6: Integration Points & Architecture Decisions

**Date**: December 25, 2025  
**Status**: Complete Design  
**Scope**: Electron integration, IPC protocols, config management, deployment decisions

---

## Executive Summary

**Key Decisions**:
1. ✅ CLI as primary interface; Electron integration optional
2. ✅ JSON files for CLI-Electron communication (simple, no external deps)
3. ✅ Shared config in `public/data/`
4. ✅ Save files in `game-data/saves/` (user-specific)
5. ✅ WebSocket for real-time game inspection (Phase 3+)
6. ✅ Backward compatibility = zero breaking changes

---

## Decision 1: CLI vs. Electron UI

### Question
Should game-tools be CLI-only or integrated into Electron dev UI?

### Options
- **A) CLI-Only**: Leaner; tools can run independently
- **B) Electron Integration**: Dev window shows tool outputs
- **C) Both**: CLI primary; Electron panel secondary

### Decision: ✅ **OPTION C - CLI PRIMARY + OPTIONAL ELECTRON PANEL**

**Rationale**:
- Developers use CLI directly (faster, scriptable)
- Electron panel helpful but not required
- Gradual integration possible (Electron can consume CLI JSON outputs)

**Implementation**:
- **Phase 1-4**: Full CLI functionality
- **Phase 5+**: Optional Electron integration (read JSON files generated by CLI)

**Not Required for MVP**:
- Real-time Electron updates
- Electron menus for tools
- Can be added later without breaking CLI

---

## Decision 2: CLI ↔ Electron Communication

### Question
How should CLI tools send data to Electron during dev?

### Options
- **A) JSON Files**: CLI writes to file; Electron reads periodically
- **B) Socket.io**: Real-time WebSocket streaming
- **C) IPC Direct**: Child process communication
- **D) HTTP Server**: Each tool runs server; Electron queries

### Decision: ✅ **OPTION A - JSON FILES** (Phase 1-4)

**Rationale**:
- Simplest implementation
- No external dependencies
- Reliable and testable
- Works with existing tools immediately
- Easy to upgrade to sockets later

**File Structure**:
```
game-data/
├── saves/                          # Save files
│   ├── slot1.json
│   ├── slot2.json
│   └── slot3.json
├── tool-outputs/                   # CLI tool outputs
│   ├── latest-analysis.json        # From: game-tools analyze
│   ├── latest-balance-report.json  # From: game-tools test-balance
│   ├── latest-optimization.json    # From: game-tools optimize
│   └── latest-inspection.json      # From: game-tools inspect-save
└── inspector/                      # From: game-tools inspect-game
    └── game-state.json            # Live game state (WebSocket, Phase 3+)
```

**Example Usage**:
```bash
# CLI generates report
$ npm run game-tools -- test-balance curves --output game-data/tool-outputs/latest-balance-report.json

# Electron watches file and updates UI
const report = JSON.parse(fs.readFileSync('game-data/tool-outputs/latest-balance-report.json'));
```

**Upgrade Path** (Phase 3+ optional):
- Add WebSocket server in inspector
- Electron connects and gets real-time updates
- JSON files still used as fallback

---

## Decision 3: Configuration Source of Truth

### Question
Where should tools read game configuration?

### Options
- **A) public/data/**: Shared with game (single source)
- **B) tools/config/**: Separate, tools only
- **C) Both**: Game config + tool overrides

### Decision: ✅ **OPTION A - public/data/ SINGLE SOURCE**

**Rationale**:
- Game and tools use identical config
- No duplication or sync issues
- Non-code changes (balance, items) in one place
- Easy to version control

**Shared Files**:
```
public/data/
├── palettes.json               # Extracted from PaletteManager
├── stats-config.json           # Player/enemy stats progression
├── world-config.json           # Zone, level, difficulty config
├── items.json                  # Item definitions with costs
├── enemies.json                # Enemy definitions and drops
├── prestige-config.json        # Prestige mechanics
├── specializations.json        # Character specializations
├── classes.json                # Character classes
└── achievements.json           # Achievement definitions
```

**Tools Load**:
```javascript
const config = new GameConfig();
config.loadAll(); // Loads all public/data/*.json files

const stats = config.get('stats-config');
const items = config.get('items');
const enemies = config.get('enemies');
```

**Benefits**:
- Content creators edit one set of files
- Game and tools always in sync
- Easy to test balance changes
- Clear separation between code and config

---

## Decision 4: Save File Location & Format

### Question
Where should player save files be stored and how?

### Options
- **A) game-data/saves/**: Separate folder, simple JSON
- **B) user home/.road-of-war/**: OS-standard location
- **C) IndexedDB in Electron**: App-local, not accessible from CLI

### Decision: ✅ **OPTION A - game-data/saves/ (dev)**

**Rationale** (Development):
- Saves visible to CLI tools
- Easy to backup/version control
- Works on all platforms
- Accessible from Electron and CLI equally

**File Format**:
```json
{
  "_meta": {
    "version": "1.0.0",
    "slot": 1,
    "createdAt": "2025-12-25T10:00:00Z",
    "updatedAt": "2025-12-25T10:30:00Z"
  },
  "character": { ... },
  "inventory": [ ... ],
  ...
}
```

**Note on Production**:
- In released game: use OS-standard location (user home)
- For development: game-data/saves/ works great
- Electron can support both with environment variable

**Directory Structure**:
```
game-data/
├── saves/
│   ├── slot1.json              # Player save
│   ├── slot2.json
│   ├── slot3.json
│   └── auto-save.json          # Auto-save slot
├── tool-outputs/               # CLI tool results
│   ├── latest-balance-report.json
│   ├── latest-inspection.json
│   └── latest-optimization.json
├── logs/                       # Debug logs
│   └── game.log
└── cache/                      # Generated assets cache
    └── .asset-cache/
```

---

## Decision 5: Real-Time Game Inspection (Phase 3+)

### Question
How should game-tools inspect-game communicate with running game?

### Options
- **A) Polling JSON files**: Electron writes state; CLI reads
- **B) WebSocket**: Bi-directional real-time
- **C) Unix sockets**: Local-only, fast
- **D) File watching**: Watch for changes

### Decision: ✅ **OPTION B - WEBSOCKET** (Phase 3+ implementation)

**Rationale**:
- Standard, well-supported protocol
- Real-time updates
- Works across network (dev machine + device)
- Graceful fallback if server unavailable
- No polling overhead

**Architecture**:
```
Electron App (Port 3000)
    ↓ (every 100ms)
WebSocket Client → sends game state
    ↓
game-tools inspect-game Server (Port 5555)
    ↓ (broadcasts to all clients)
CLI Query Commands
```

**Implementation** (Phase 3):
```javascript
// In Electron game loop
const gameState = {
  party: party.getState(),
  world: world.getState(),
  combat: combatManager.getState(),
  timestamp: Date.now()
};

ws.send(JSON.stringify({
  type: 'state-update',
  data: gameState
}));

// In CLI
$ game-tools inspect-game start    # Starts server on 5555
$ game-tools inspect-game query party.heroes[0].health
```

**Fallback** (if WebSocket unavailable):
- CLI tools work normally (no Electron integration)
- Developers use inspect-save for save file inspection
- No broken workflows

---

## Decision 6: Error Handling & Validation

### Question
Should tools validate against game data schemas?

### Options
- **A) Strict validation**: Enforce all schemas
- **B) Loose validation**: Trust inputs, warn on errors
- **C) Selective validation**: Check critical fields only

### Decision: ✅ **OPTION C - SELECTIVE VALIDATION**

**Critical Fields** (always validate):
- Save file required structure (`_meta`, `character`, `inventory`)
- Item IDs must exist in game config
- Character classes must be valid
- Level numbers in valid range

**Non-Critical** (warn but don't block):
- Minor metadata inconsistencies
- Old timestamp formats
- Missing optional fields
- Deprecated features

**Implementation**:
```javascript
function validateSave(save) {
  const errors = [];      // Critical issues
  const warnings = [];    // Non-critical warnings
  
  // Critical validation
  if (!save._meta) {
    errors.push('Missing _meta object');
  }
  
  // Non-critical validation
  if (save._meta?.version !== currentVersion) {
    warnings.push(`Old save format (v${save._meta.version})`);
  }
  
  return { valid: errors.length === 0, errors, warnings };
}
```

**Error Handling**:
```bash
# Invalid: stops execution
$ game-tools inspect-save load missing-file.json
Error: File not found (error code 1)

# Warning: shows message but continues
$ game-tools inspect-save load old-save.json
⚠ Warning: Save file is old format (v0.9.0)
  Recommendation: Run: game-tools inspect-save migrate --target 1.0.0
```

---

## Decision 7: Logging & Debugging

### Question
What logging approach for CLI tools?

### Options
- **A) Console only**: No file logging
- **B) File logging**: All output to file
- **C) Both**: Console + optional file

### Decision: ✅ **OPTION C - CONSOLE + OPTIONAL FILE**

**Default Behavior**:
- Output to console (user sees immediately)
- Can add `--log-file` to save to `game-tools.log`
- `--verbose` for detailed debugging
- `--quiet` to suppress non-error output

**Log File Location**:
- Default: `game-tools.log` in current directory
- Configurable via `--log-file` option

**Log Format**:
```
[2025-12-25T10:30:45.123Z] [INFO] Starting analysis...
[2025-12-25T10:30:46.456Z] [DEBUG] Loaded palette: warm
[2025-12-25T10:30:47.789Z] [SUCCESS] Analysis complete
```

**Log Retention**:
- Keep last 10 log files (rotate)
- Each file ~1MB max
- No automatic cleanup required (developer maintains)

---

## Decision 8: Performance Targets

### Question
What performance requirements for tools?

### Options
- **A) No targets**: Best effort
- **B) Loose targets**: < 5s startup
- **C) Strict targets**: < 500ms startup, generation < 30s

### Decision: ✅ **OPTION C - STRICT TARGETS**

**CLI Tool Startup**:
- Target: < 500ms from invocation to ready
- Acceptable: < 1s
- Unacceptable: > 2s

**Asset Generation**:
- Target: < 30s for 100 sprites
- = < 300ms per sprite
- Current average: ~50ms/sprite ✅

**Balance Testing**:
- Target: < 10s for full analysis
- Must complete before output
- Async operations okay if streaming results

**Game Inspector**:
- Target: < 100ms query latency
- Game FPS impact: < 5% overhead
- Memory impact: < 10MB

**Monitoring**:
```bash
$ npm run game-tools -- analyze --profile --input ref.png
Time breakdown:
  Load image:       50ms
  Quantize colors:  150ms
  Analyze style:    200ms
  Detect regions:   100ms
  Total:            500ms ✓
```

---

## Decision 9: Distribution & Installation

### Question
How should developers install and use game-tools?

### Options
- **A) npm script only**: `npm run game-tools`
- **B) Global install**: `npm i -g; game-tools`
- **C) Local CLI**: Both A and B

### Decision: ✅ **OPTION C - BOTH METHODS**

**Method 1: npm script** (recommended for project):
```bash
npm run game-tools -- analyze --input ref.png
npm run game-tools -- generate --count 50
npm run game-tools -- test-balance curves
```

**Method 2: Global** (optional for power users):
```bash
npm install -g road-of-war
game-tools analyze --input ref.png
```

**Implementation** (in package.json):
```json
{
  "scripts": {
    "game-tools": "node tools/cli.js",
    "generate-assets": "npm run game-tools -- generate",
    "analyze-reference": "npm run game-tools -- analyze"
  },
  "bin": {
    "game-tools": "tools/cli.js"
  }
}
```

**Shebang** (in tools/cli.js):
```javascript
#!/usr/bin/env node
```

**Benefits**:
- Works immediately (no install step)
- Optional global install for convenience
- Clear relationship to project

---

## Decision 10: Version Compatibility

### Question
How to handle version changes to CLI and game config?

### Options
- **A) Strict versions**: CLI v2 only works with game v2
- **B) Loose versions**: CLI forwards compatible
- **C) Metadata**: Track version in configs and saves

### Decision: ✅ **OPTION C - METADATA TRACKING**

**Version Numbers**:
- CLI version: in `package.json` (`1.0.0`)
- Config version: in `public/data/meta.json` (`1.0.0`)
- Save format version: in `save._meta.version` (`1.0.0`)

**Example Migration**:
```
Config v1.0.0 + CLI v1.0.0  ✓ Compatible
Config v1.1.0 + CLI v1.0.0  ✓ Compatible (new fields have defaults)
Config v1.0.0 + CLI v1.1.0  ✓ Compatible (old config works)
Config v2.0.0 + CLI v1.0.0  ✗ Incompatible (requires migration)

# Migration command
$ game-tools migrate config v1.0.0 -> v2.0.0
```

**File Locations**:
- `package.json` → CLI version
- `public/data/meta.json` → Config version
- `save._meta.version` → Save format version

---

## Decision 11: Testing Strategy

### Question
What testing approach for CLI tools?

### Options
- **A) Manual only**: Developers test by hand
- **B) Unit tests**: Test functions in isolation
- **C) Integration tests**: Test CLI commands end-to-end
- **D) All above**: Comprehensive coverage

### Decision: ✅ **OPTION D - COMPREHENSIVE TESTING**

**Test Structure**:
```
tests/
├── unit/
│   ├── config.test.js              # GameConfig loading
│   ├── logger.test.js              # Logger system
│   ├── save-validator.test.js      # Save validation
│   └── formatters.test.js          # Output formatting
├── integration/
│   ├── cli.test.js                 # CLI router
│   ├── commands/
│   │   ├── analyze.test.js
│   │   ├── generate.test.js
│   │   ├── inspect-save.test.js
│   │   ├── test-balance.test.js
│   │   ├── inspect-game.test.js
│   │   └── optimize.test.js
│   └── end-to-end.test.js          # Full workflow
└── fixtures/
    ├── sample-save.json            # Test save files
    ├── sample-config.json          # Test configs
    └── sample-images/              # Test images
```

**Test Commands**:
```bash
npm test                  # Run all tests
npm run test:unit        # Unit tests only
npm run test:integration # Integration tests only
npm run test:coverage    # Coverage report
```

**Coverage Targets**:
- Statements: 80%+
- Branches: 75%+
- Functions: 80%+
- Lines: 80%+

---

## Decision 12: Documentation Levels

### Question
How much documentation needed?

### Options
- **A) Minimal**: Just command help
- **B) Standard**: README + help text
- **C) Comprehensive**: README + guides + API docs

### Decision: ✅ **OPTION C - COMPREHENSIVE**

**Documentation Files**:
1. **tools/README.md** - Complete reference
   - What each tool does
   - Installation
   - Quick start
   - Full command reference
   - Examples for each command

2. **tools/ARCHITECTURE.md** - System design
   - CLI design decisions
   - Component overview
   - Data flows
   - IPC protocols

3. **tools/DEV_GUIDE.md** - For developers extending CLI
   - How to add new subcommands
   - How to add new infrastructure modules
   - Testing conventions
   - Code style

4. **tools/TROUBLESHOOTING.md** - Common issues
   - Common errors and fixes
   - Performance issues
   - Electron integration issues

5. **Command help text** - In CLI itself
   - `game-tools --help`
   - `game-tools analyze --help`
   - Actionable error messages

---

## Summary Table

| Decision | Option | Rationale |
|----------|--------|-----------|
| CLI vs Electron | CLI primary + optional Electron | Flexibility, no breaking |
| CLI-Electron Comms | JSON files (Phase 1-4) | Simple, reliable, no deps |
| Config Source | public/data/ (single) | No duplication, easy sync |
| Save Files | game-data/saves/ JSON | Accessible from both systems |
| Game Inspection | WebSocket (Phase 3+) | Real-time, standard protocol |
| Validation | Selective (critical only) | Don't block on non-critical |
| Logging | Console + optional file | Flexible debugging |
| Performance | Strict targets | Ensure good UX |
| Distribution | npm script + optional global | Convenient for both |
| Versioning | Metadata tracking | Handle migrations cleanly |
| Testing | Comprehensive (unit + integration) | High confidence |
| Documentation | Comprehensive (README + guides) | Accessible to all levels |

---

## Integration Diagram

```
Developer
    ↓
npm run game-tools -- analyze
    ↓
tools/cli.js (router)
    ↓
tools/commands/analyze.js
    ↓
tools/utils/image-analyzer.js
tools/config/game-config.js (loads public/data/*.json)
tools/logging/logger.js
    ↓
Output: game-data/tool-outputs/latest-analysis.json
    ↓
(Optional) Electron reads file and updates UI
```

---

## Risk Mitigation

| Risk | Mitigation |
|------|------------|
| Configuration drift | Single source (public/data/) |
| Backward compat breaks | Extensive testing + wrappers |
| Unaccounted for dependencies | Phase 1 audit complete |
| Performance regressions | Performance targets + profiling |
| Save file corruption | Validation + repair tool |
| Incomplete documentation | Multiple doc formats + examples |

---

## Next Steps

1. ✅ Phase 6 architecture decisions complete
2. → **Phase 7**: Final deliverables checklist & success criteria
3. → **Begin Implementation**: Phase 5 Week 1-4 roadmap

**All architectural decisions made and documented. Ready for Phase 7 final deliverables.**
