<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hero Visibility Debugger</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        body {
            background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
            color: white;
            font-family: system-ui, -apple-system, sans-serif;
        }
        .code-block {
            background: #020617;
            border: 1px solid #1e293b;
        }
        .severity-high { background: rgba(239, 68, 68, 0.2); color: #fca5a5; }
        .severity-medium { background: rgba(234, 179, 8, 0.2); color: #fde047; }
        .severity-low { background: rgba(59, 130, 246, 0.2); color: #93c5fd; }
    </style>
</head>
<body class="min-h-screen p-6">
    <div class="w-full max-w-5xl mx-auto">
        <div class="mb-6">
            <h1 class="text-3xl font-bold mb-2 flex items-center gap-3">
                <i data-lucide="eye" class="w-8 h-8 text-blue-400"></i>
                Hero Visibility Debugger
            </h1>
            <p class="text-slate-300">
                Diagnostic tool for investigating missing hero sprites in Phaser game
            </p>
        </div>

        <div class="mb-6 p-4 bg-slate-800 rounded-lg border border-slate-700">
            <h2 class="text-xl font-semibold mb-3">Quick Actions</h2>
            <div class="flex flex-wrap gap-2">
                <button onclick="runFullDiagnostic()" class="px-4 py-2 bg-blue-600 hover:bg-blue-700 rounded font-medium transition">
                    Run Full Diagnostic
                </button>
                <button onclick="forceAllVisible()" class="px-4 py-2 bg-green-600 hover:bg-green-700 rounded font-medium transition">
                    Force All Visible
                </button>
                <button onclick="logHeroStates()" class="px-4 py-2 bg-purple-600 hover:bg-purple-700 rounded font-medium transition">
                    Log Hero States
                </button>
                <button onclick="checkCameraBounds()" class="px-4 py-2 bg-orange-600 hover:bg-orange-700 rounded font-medium transition">
                    Check Camera Bounds
                </button>
            </div>
            <div id="diagnostic-results" class="mt-4 hidden"></div>
        </div>

        <div class="space-y-4">
            <h2 class="text-xl font-semibold mb-3">Potential Issues</h2>
            
            <div class="bg-slate-800 rounded-lg border border-slate-700 overflow-hidden">
                <button onclick="toggleIssue('positioning')" class="w-full p-4 flex items-center gap-3 hover:bg-slate-750 transition text-left">
                    <div class="p-2 rounded severity-high">
                        <i data-lucide="map-pin" class="w-5 h-5"></i>
                    </div>
                    <div class="flex-1">
                        <h3 class="font-semibold text-lg">Off-Screen Positioning</h3>
                        <p class="text-sm text-slate-400">Heroes positioned at world coordinates (0,0) with offsets. If camera isn't following correctly, they may be outside viewport.</p>
                    </div>
                    <div class="px-2 py-1 rounded text-xs font-medium severity-high">HIGH</div>
                </button>
                <div id="issue-positioning" class="hidden p-4 bg-slate-900 border-t border-slate-700">
                    <h4 class="font-semibold mb-2 text-slate-300">Investigation Checklist:</h4>
                    <ul class="space-y-1 mb-4 text-sm text-slate-400">
                        <li>□ Verify camera scrollX/scrollY values</li>
                        <li>□ Check if hero positions are within camera bounds</li>
                        <li>□ Confirm camera is following tank sprite (hero_4)</li>
                        <li>□ Validate CameraManager offset calculations</li>
                    </ul>
                    <h4 class="font-semibold mb-2 text-slate-300">Debug Script:</h4>
                    <pre class="code-block p-3 rounded text-xs text-green-400 overflow-x-auto" onclick="copyToClipboard(this)">const camera = window.gameScene?.cameras?.main;
if (!camera) {
  console.error('Game scene not found! Make sure game is running.');
  return;
}

const viewport = {
  left: camera.scrollX,
  right: camera.scrollX + camera.width,
  top: camera.scrollY,
  bottom: camera.scrollY + camera.height
};

const scene = window.gameScene;
if (!scene.partyMemberSprites) {
  console.error('Party member sprites not found!');
  return;
}

scene.partyMemberSprites.forEach((pm, i) => {
  const sprite = pm.sprite;
  if (!sprite) {
    console.log(`Hero ${i}: NO SPRITE`);
    return;
  }
  const inView = sprite.x >= viewport.left && 
                 sprite.x <= viewport.right &&
                 sprite.y >= viewport.top && 
                 sprite.y <= viewport.bottom;
  console.log(`Hero ${i} (${pm.hero?.id || 'unknown'}):`, {
    position: { x: sprite.x, y: sprite.y },
    inView: inView ? '✓ IN VIEW' : '✗ OFF-SCREEN',
    viewport: viewport
  });
});</pre>
                    <button onclick="runPositionCheck()" class="mt-2 px-3 py-1 bg-blue-600 hover:bg-blue-700 rounded text-sm">
                        Run This Check
                    </button>
                </div>
            </div>

            <div class="bg-slate-800 rounded-lg border border-slate-700 overflow-hidden">
                <button onclick="toggleIssue('depth')" class="w-full p-4 flex items-center gap-3 hover:bg-slate-750 transition text-left">
                    <div class="p-2 rounded severity-medium">
                        <i data-lucide="layers" class="w-5 h-5"></i>
                    </div>
                    <div class="flex-1">
                        <h3 class="font-semibold text-lg">Depth Ordering Conflicts</h3>
                        <p class="text-sm text-slate-400">hero_3 has depth 1040, placed between DPS3 (1030) and Tank (1050). Overlapping sprites may hide heroes.</p>
                    </div>
                    <div class="px-2 py-1 rounded text-xs font-medium severity-medium">MEDIUM</div>
                </button>
                <div id="issue-depth" class="hidden p-4 bg-slate-900 border-t border-slate-700">
                    <h4 class="font-semibold mb-2 text-slate-300">Investigation Checklist:</h4>
                    <ul class="space-y-1 mb-4 text-sm text-slate-400">
                        <li>□ Compare hero depths with other game objects</li>
                        <li>□ Check if background/foreground elements use conflicting depths</li>
                        <li>□ Verify hero_3 special positioning (-20, -20 offset)</li>
                        <li>□ Look for z-index style layering issues</li>
                    </ul>
                    <h4 class="font-semibold mb-2 text-slate-300">Debug Script:</h4>
                    <pre class="code-block p-3 rounded text-xs text-green-400 overflow-x-auto" onclick="copyToClipboard(this)">const scene = window.gameScene;
if (!scene.partyMemberSprites) {
  console.error('Party member sprites not found!');
  return;
}

console.log('=== Hero Depths ===');
scene.partyMemberSprites.forEach((pm, i) => {
  console.log(`Hero ${i} (${pm.hero?.id || 'unknown'}): depth=${pm.sprite?.depth || 'N/A'}`);
});

console.log('\n=== Other Objects at Similar Depths ===');
scene.children.list
  .filter(obj => obj.depth >= 1000 && obj.depth <= 1100)
  .sort((a, b) => a.depth - b.depth)
  .forEach(obj => {
    console.log(`Depth ${obj.depth}: ${obj.type} (${obj.texture?.key || 'no texture'})`);
  });</pre>
                    <button onclick="runDepthCheck()" class="mt-2 px-3 py-1 bg-blue-600 hover:bg-blue-700 rounded text-sm">
                        Run This Check
                    </button>
                </div>
            </div>

            <div class="bg-slate-800 rounded-lg border border-slate-700 overflow-hidden">
                <button onclick="toggleIssue('texture')" class="w-full p-4 flex items-center gap-3 hover:bg-slate-750 transition text-left">
                    <div class="p-2 rounded severity-high">
                        <i data-lucide="eye" class="w-5 h-5"></i>
                    </div>
                    <div class="flex-1">
                        <h3 class="font-semibold text-lg">Invisible Texture / White Tint</h3>
                        <p class="text-sm text-slate-400">Sprites use class color tints (NOT white). If texture generation fails or background is light, sprites become invisible.</p>
                    </div>
                    <div class="px-2 py-1 rounded text-xs font-medium severity-high">HIGH</div>
                </button>
                <div id="issue-texture" class="hidden p-4 bg-slate-900 border-t border-slate-700">
                    <h4 class="font-semibold mb-2 text-slate-300">Investigation Checklist:</h4>
                    <ul class="space-y-1 mb-4 text-sm text-slate-400">
                        <li>□ Verify texture "hero-sprite" exists in texture manager</li>
                        <li>□ Check if SpriteGenerator succeeded or fell back to rectangle</li>
                        <li>□ Confirm sprites don't have white tint (0xFFFFFF)</li>
                        <li>□ Test if background color matches sprite tint colors</li>
                    </ul>
                    <h4 class="font-semibold mb-2 text-slate-300">Debug Script:</h4>
                    <pre class="code-block p-3 rounded text-xs text-green-400 overflow-x-auto" onclick="copyToClipboard(this)">const scene = window.gameScene;
if (!scene) {
  console.error('Game scene not found!');
  return;
}

console.log('Texture exists:', scene.textures.exists('hero-sprite'));

if (!scene.partyMemberSprites) {
  console.error('Party member sprites not found!');
  return;
}

scene.partyMemberSprites.forEach((pm, i) => {
  const sprite = pm.sprite;
  if (!sprite) {
    console.log(`Hero ${i}: NO SPRITE`);
    return;
  }
  const tint = sprite.tintTopLeft || sprite.tint || 0;
  const tintHex = '0x' + tint.toString(16).padStart(6, '0').toUpperCase();
  const isWhite = tint === 0xFFFFFF || tint === 16777215;
  
  console.log(`Hero ${i} (${pm.hero?.id || 'unknown'}):`, {
    texture: sprite.texture?.key || 'N/A',
    tint: tintHex + (isWhite ? ' ⚠️ WHITE!' : ''),
    alpha: sprite.alpha,
    scaleX: sprite.scaleX,
    scaleY: sprite.scaleY,
    visible: sprite.visible,
    active: sprite.active
  });
});

console.log('\n=== Quick Fix: Remove All Tints ===');
console.log('Run: window.gameScene.partyMemberSprites.forEach(pm => pm.sprite.clearTint());');</pre>
                    <button onclick="runTextureCheck()" class="mt-2 px-3 py-1 bg-blue-600 hover:bg-blue-700 rounded text-sm">
                        Run This Check
                    </button>
                    <button onclick="clearAllTints()" class="mt-2 ml-2 px-3 py-1 bg-yellow-600 hover:bg-yellow-700 rounded text-sm">
                        Clear All Tints
                    </button>
                </div>
            </div>

            <div class="bg-slate-800 rounded-lg border border-slate-700 overflow-hidden">
                <button onclick="toggleIssue('camera')" class="w-full p-4 flex items-center gap-3 hover:bg-slate-750 transition text-left">
                    <div class="p-2 rounded severity-medium">
                        <i data-lucide="camera" class="w-5 h-5"></i>
                    </div>
                    <div class="flex-1">
                        <h3 class="font-semibold text-lg">Camera Follow Configuration</h3>
                        <p class="text-sm text-slate-400">Camera follows tank (hero_4), not center hero. If tank positioning is wrong, entire party moves off-screen.</p>
                    </div>
                    <div class="px-2 py-1 rounded text-xs font-medium severity-medium">MEDIUM</div>
                </button>
                <div id="issue-camera" class="hidden p-4 bg-slate-900 border-t border-slate-700">
                    <h4 class="font-semibold mb-2 text-slate-300">Investigation Checklist:</h4>
                    <ul class="space-y-1 mb-4 text-sm text-slate-400">
                        <li>□ Confirm camera.followTarget is hero_4 sprite</li>
                        <li>□ Verify CameraManager calculates party bounding box correctly</li>
                        <li>□ Check if followOffset properly centers the party</li>
                        <li>□ Test if camera lerp/smoothing causes position lag</li>
                    </ul>
                    <h4 class="font-semibold mb-2 text-slate-300">Debug Script:</h4>
                    <pre class="code-block p-3 rounded text-xs text-green-400 overflow-x-auto" onclick="copyToClipboard(this)">const scene = window.gameScene;
if (!scene) {
  console.error('Game scene not found!');
  return;
}

const camera = scene.cameras.main;
console.log('=== Camera State ===');
console.log('Follow target:', camera.followTarget);
console.log('Camera position:', { 
  scrollX: camera.scrollX, 
  scrollY: camera.scrollY,
  width: camera.width,
  height: camera.height
});
console.log('Follow offset:', camera.followOffset);

if (scene.partyMemberSprites && scene.partyMemberSprites.length > 0) {
  const positions = scene.partyMemberSprites.map(pm => ({
    x: pm.sprite?.x || 0,
    y: pm.sprite?.y || 0,
    id: pm.hero?.id || 'unknown'
  }));
  
  const minX = Math.min(...positions.map(p => p.x));
  const maxX = Math.max(...positions.map(p => p.x));
  const minY = Math.min(...positions.map(p => p.y));
  const maxY = Math.max(...positions.map(p => p.y));
  const centerX = (minX + maxX) / 2;
  const centerY = (minY + maxY) / 2;
  
  console.log('\n=== Party Bounds ===');
  console.log('Min X:', minX, 'Max X:', maxX);
  console.log('Min Y:', minY, 'Max Y:', maxY);
  console.log('Center:', { x: centerX, y: centerY });
  console.log('Camera center should be at:', centerX);
  console.log('Camera is actually at:', camera.scrollX + camera.width / 2);
  console.log('Difference:', Math.abs((camera.scrollX + camera.width / 2) - centerX));
}</pre>
                    <button onclick="runCameraCheck()" class="mt-2 px-3 py-1 bg-blue-600 hover:bg-blue-700 rounded text-sm">
                        Run This Check
                    </button>
                </div>
            </div>

            <div class="bg-slate-800 rounded-lg border border-slate-700 overflow-hidden">
                <button onclick="toggleIssue('update')" class="w-full p-4 flex items-center gap-3 hover:bg-slate-750 transition text-left">
                    <div class="p-2 rounded severity-low">
                        <i data-lucide="refresh-cw" class="w-5 h-5"></i>
                    </div>
                    <div class="flex-1">
                        <h3 class="font-semibold text-lg">Update Loop Throttling</h3>
                        <p class="text-sm text-slate-400">Visibility checks throttled to 100ms. Sprites hidden between checks stay invisible temporarily, causing flicker.</p>
                    </div>
                    <div class="px-2 py-1 rounded text-xs font-medium severity-low">LOW</div>
                </button>
                <div id="issue-update" class="hidden p-4 bg-slate-900 border-t border-slate-700">
                    <h4 class="font-semibold mb-2 text-slate-300">Investigation Checklist:</h4>
                    <ul class="space-y-1 mb-4 text-sm text-slate-400">
                        <li>□ Monitor visibility state over multiple frames</li>
                        <li>□ Check if sprites get hidden then restored in cycles</li>
                        <li>□ Verify throttle timing doesn't conflict with other systems</li>
                        <li>□ Test if removing throttle fixes visibility</li>
                    </ul>
                    <h4 class="font-semibold mb-2 text-slate-300">Debug Script:</h4>
                    <pre class="code-block p-3 rounded text-xs text-green-400 overflow-x-auto" onclick="copyToClipboard(this)">const scene = window.gameScene;
if (!scene || !scene.partyMemberSprites) {
  console.error('Game scene or party sprites not found!');
  return;
}

console.log('Monitoring visibility over 10 checks (every 50ms)...');
let count = 0;
const interval = setInterval(() => {
  console.log(`\n=== Check ${count + 1} ===`);
  scene.partyMemberSprites.forEach((pm, i) => {
    const sprite = pm.sprite;
    if (!sprite) {
      console.log(`  Hero ${i}: NO SPRITE`);
      return;
    }
    console.log(`  Hero ${i} (${pm.hero?.id || 'unknown'}):`, {
      visible: sprite.visible ? '✓' : '✗',
      active: sprite.active ? '✓' : '✗',
      alpha: sprite.alpha
    });
  });
  count++;
  if (count >= 10) {
    clearInterval(interval);
    console.log('\nMonitoring complete.');
  }
}, 50);</pre>
                    <button onclick="runUpdateCheck()" class="mt-2 px-3 py-1 bg-blue-600 hover:bg-blue-700 rounded text-sm">
                        Run This Check
                    </button>
                </div>
            </div>

            <div class="bg-slate-800 rounded-lg border border-slate-700 overflow-hidden">
                <button onclick="toggleIssue('async')" class="w-full p-4 flex items-center gap-3 hover:bg-slate-750 transition text-left">
                    <div class="p-2 rounded severity-medium">
                        <i data-lucide="alert-circle" class="w-5 h-5"></i>
                    </div>
                    <div class="flex-1">
                        <h3 class="font-semibold text-lg">Async Animation Loading</h3>
                        <p class="text-sm text-slate-400">Animations initialize asynchronously. If loading fails or takes too long, sprites may not display properly.</p>
                    </div>
                    <div class="px-2 py-1 rounded text-xs font-medium severity-medium">MEDIUM</div>
                </button>
                <div id="issue-async" class="hidden p-4 bg-slate-900 border-t border-slate-700">
                    <h4 class="font-semibold mb-2 text-slate-300">Investigation Checklist:</h4>
                    <ul class="space-y-1 mb-4 text-sm text-slate-400">
                        <li>□ Verify animation promises resolve successfully</li>
                        <li>□ Check if idle animations exist for all hero types</li>
                        <li>□ Confirm sprites display before animations load</li>
                        <li>□ Test if animation errors prevent sprite rendering</li>
                    </ul>
                    <h4 class="font-semibold mb-2 text-slate-300">Debug Script:</h4>
                    <pre class="code-block p-3 rounded text-xs text-green-400 overflow-x-auto" onclick="copyToClipboard(this)">const scene = window.gameScene;
if (!scene || !scene.partyMemberSprites) {
  console.error('Game scene or party sprites not found!');
  return;
}

scene.partyMemberSprites.forEach((pm, i) => {
  const hero = pm.hero;
  if (!hero) {
    console.log(`Hero ${i}: NO HERO DATA`);
    return;
  }
  
  const characterType = (hero.classId || 'paladin').toLowerCase();
  const characterId = hero.id || `hero_${i}`;
  const idleKey = `${characterType}-${characterId}-idle`;
  const walkKey = `${characterType}-${characterId}-walk`;
  
  console.log(`Hero ${i} (${hero.id}):`, {
    class: characterType,
    idleAnimation: scene.anims.exists(idleKey) ? '✓ EXISTS' : '✗ MISSING',
    walkAnimation: scene.anims.exists(walkKey) ? '✓ EXISTS' : '✗ MISSING',
    currentAnimation: pm.sprite?.anims?.currentAnim?.key || 'NONE'
  });
});

console.log('\n=== All Available Animations ===');
const allAnims = scene.anims.anims.entries;
Object.keys(allAnims).filter(k => k.includes('hero')).forEach(key => {
  console.log(`  ${key}`);
});</pre>
                    <button onclick="runAnimationCheck()" class="mt-2 px-3 py-1 bg-blue-600 hover:bg-blue-700 rounded text-sm">
                        Run This Check
                    </button>
                </div>
            </div>
        </div>

        <div class="mt-6 p-4 bg-blue-900/30 border border-blue-700 rounded-lg">
            <h3 class="font-semibold mb-2 flex items-center gap-2">
                <i data-lucide="alert-circle" class="w-5 h-5"></i>
                Most Likely Causes (Priority Order)
            </h3>
            <ol class="text-sm text-slate-300 space-y-2">
                <li><strong>1. Off-Screen Positioning:</strong> Heroes at (0,0) with offsets - camera may not be positioned to show them</li>
                <li><strong>2. Invisible Texture/Tint:</strong> Failed texture generation or color tint blending with background</li>
                <li><strong>3. Camera Follow Issue:</strong> Following tank but offset calculation is wrong, leaving party outside viewport</li>
            </ol>
        </div>
    </div>

    <script>
        lucide.createIcons();

        function toggleIssue(id) {
            const element = document.getElementById(`issue-${id}`);
            element.classList.toggle('hidden');
        }

        function copyToClipboard(element) {
            const text = element.textContent;
            navigator.clipboard.writeText(text).then(() => {
                alert('Code copied to clipboard!');
            });
        }

        function getGameScene() {
            // Try current window first
            if (typeof window !== 'undefined' && window.gameScene) {
                return window.gameScene;
            }
            
            // Try to access parent window (if in iframe)
            try {
                if (window.parent && window.parent !== window && window.parent.gameScene) {
                    return window.parent.gameScene;
                }
            } catch (e) {
                // Cross-origin restriction, ignore
            }
            
            // Try opener window (if opened from game)
            try {
                if (window.opener && window.opener.gameScene) {
                    return window.opener.gameScene;
                }
            } catch (e) {
                // Cross-origin restriction, ignore
            }
            
            // Show helpful error message
            const message = 'Game scene not found!\n\n' +
                'To use this debugger:\n' +
                '1. Make sure the game is running at http://localhost:3000\n' +
                '2. Open this debugger in a NEW TAB (keep game tab open)\n' +
                '3. Or use the browser console in the game tab directly\n\n' +
                'Alternative: Open browser console (F12) in the game tab and run:\n' +
                'window.gameScene.partyMemberSprites.forEach((pm,i) => console.log(`Hero ${i}:`, pm.sprite?.visible, pm.sprite?.x, pm.sprite?.y));';
            
            alert(message);
            return null;
        }

        function runFullDiagnostic() {
            const scene = getGameScene();
            if (!scene) return;

            const results = [];
            
            // Check 1: Positioning
            const camera = scene.cameras.main;
            const viewport = {
                left: camera.scrollX,
                right: camera.scrollX + camera.width,
                top: camera.scrollY,
                bottom: camera.scrollY + camera.height
            };
            
            let offScreenCount = 0;
            scene.partyMemberSprites?.forEach((pm, i) => {
                if (pm.sprite) {
                    const inView = pm.sprite.x >= viewport.left && 
                                 pm.sprite.x <= viewport.right &&
                                 pm.sprite.y >= viewport.top && 
                                 pm.sprite.y <= viewport.bottom;
                    if (!inView) offScreenCount++;
                }
            });
            
            results.push({
                check: 'Positioning',
                status: offScreenCount === 0 ? 'PASS' : 'FAIL',
                message: `${offScreenCount} hero(s) are off-screen`
            });

            // Check 2: Visibility
            let invisibleCount = 0;
            scene.partyMemberSprites?.forEach((pm, i) => {
                if (pm.sprite && (!pm.sprite.visible || !pm.sprite.active)) {
                    invisibleCount++;
                }
            });
            
            results.push({
                check: 'Visibility',
                status: invisibleCount === 0 ? 'PASS' : 'FAIL',
                message: `${invisibleCount} hero(s) are not visible/active`
            });

            // Check 3: Texture
            const textureExists = scene.textures.exists('hero-sprite');
            results.push({
                check: 'Texture',
                status: textureExists ? 'PASS' : 'FAIL',
                message: textureExists ? 'Hero texture exists' : 'Hero texture missing!'
            });

            // Check 4: White Tint
            let whiteTintCount = 0;
            scene.partyMemberSprites?.forEach((pm, i) => {
                if (pm.sprite) {
                    const tint = pm.sprite.tintTopLeft || pm.sprite.tint || 0;
                    if (tint === 0xFFFFFF || tint === 16777215) {
                        whiteTintCount++;
                    }
                }
            });
            
            results.push({
                check: 'Tint',
                status: whiteTintCount === 0 ? 'PASS' : 'FAIL',
                message: whiteTintCount === 0 ? 'No white tints found' : `${whiteTintCount} hero(s) have white tint!`
            });

            // Display results
            const resultsDiv = document.getElementById('diagnostic-results');
            resultsDiv.classList.remove('hidden');
            resultsDiv.innerHTML = `
                <h3 class="font-semibold mb-2">Diagnostic Results:</h3>
                <div class="space-y-2">
                    ${results.map(r => `
                        <div class="p-2 rounded ${r.status === 'PASS' ? 'bg-green-900/30' : 'bg-red-900/30'}">
                            <strong>${r.check}:</strong> ${r.status} - ${r.message}
                        </div>
                    `).join('')}
                </div>
            `;

            // Also log to console
            console.log('=== Full Diagnostic Results ===');
            results.forEach(r => console.log(`${r.check}: ${r.status} - ${r.message}`));
        }

        function forceAllVisible() {
            const scene = getGameScene();
            if (!scene) return;

            scene.partyMemberSprites?.forEach(pm => {
                if (pm.sprite) {
                    pm.sprite.setVisible(true);
                    pm.sprite.setActive(true);
                    pm.sprite.setAlpha(1.0);
                }
            });
            
            console.log('Forced all heroes visible');
            alert('All heroes forced visible!');
        }

        function logHeroStates() {
            const scene = getGameScene();
            if (!scene) return;

            console.log('=== Hero States ===');
            scene.partyMemberSprites?.forEach((pm, i) => {
                const sprite = pm.sprite;
                if (!sprite) {
                    console.log(`Hero ${i}: NO SPRITE`);
                    return;
                }
                const tint = sprite.tintTopLeft || sprite.tint || 0;
                const tintHex = '0x' + tint.toString(16).padStart(6, '0').toUpperCase();
                
                console.log(`Hero ${i} (${pm.hero?.id || 'unknown'}):`, {
                    position: { x: sprite.x, y: sprite.y },
                    visible: sprite.visible,
                    active: sprite.active,
                    alpha: sprite.alpha,
                    tint: tintHex,
                    depth: sprite.depth,
                    texture: sprite.texture?.key || 'N/A',
                    inDisplayList: scene.children.list.includes(sprite)
                });
            });
        }

        function checkCameraBounds() {
            const scene = getGameScene();
            if (!scene) return;

            const camera = scene.cameras.main;
            const viewport = {
                left: camera.scrollX,
                right: camera.scrollX + camera.width,
                top: camera.scrollY,
                bottom: camera.scrollY + camera.height
            };

            console.log('=== Camera Bounds ===');
            console.log('Viewport:', viewport);
            console.log('Follow target:', camera.followTarget);
            
            scene.partyMemberSprites?.forEach((pm, i) => {
                const sprite = pm.sprite;
                if (!sprite) return;
                
                const inView = sprite.x >= viewport.left && 
                             sprite.x <= viewport.right &&
                             sprite.y >= viewport.top && 
                             sprite.y <= viewport.bottom;
                
                console.log(`Hero ${i} (${pm.hero?.id || 'unknown'}):`, {
                    position: { x: sprite.x, y: sprite.y },
                    inView: inView ? '✓ IN VIEW' : '✗ OFF-SCREEN',
                    distanceFromViewport: {
                        left: sprite.x - viewport.left,
                        right: viewport.right - sprite.x,
                        top: sprite.y - viewport.top,
                        bottom: viewport.bottom - sprite.y
                    }
                });
            });
        }

        function runPositionCheck() {
            eval(`const camera = window.gameScene?.cameras?.main;
if (!camera) {
  console.error('Game scene not found! Make sure game is running.');
  return;
}

const viewport = {
  left: camera.scrollX,
  right: camera.scrollX + camera.width,
  top: camera.scrollY,
  bottom: camera.scrollY + camera.height
};

const scene = window.gameScene;
if (!scene.partyMemberSprites) {
  console.error('Party member sprites not found!');
  return;
}

scene.partyMemberSprites.forEach((pm, i) => {
  const sprite = pm.sprite;
  if (!sprite) {
    console.log(\`Hero \${i}: NO SPRITE\`);
    return;
  }
  const inView = sprite.x >= viewport.left && 
                 sprite.x <= viewport.right &&
                 sprite.y >= viewport.top && 
                 sprite.y <= viewport.bottom;
  console.log(\`Hero \${i} (\${pm.hero?.id || 'unknown'}):\`, {
    position: { x: sprite.x, y: sprite.y },
    inView: inView ? '✓ IN VIEW' : '✗ OFF-SCREEN',
    viewport: viewport
  });
});`);
        }

        function runDepthCheck() {
            eval(`const scene = window.gameScene;
if (!scene.partyMemberSprites) {
  console.error('Party member sprites not found!');
  return;
}

console.log('=== Hero Depths ===');
scene.partyMemberSprites.forEach((pm, i) => {
  console.log(\`Hero \${i} (\${pm.hero?.id || 'unknown'}): depth=\${pm.sprite?.depth || 'N/A'}\`);
});

console.log('\\n=== Other Objects at Similar Depths ===');
scene.children.list
  .filter(obj => obj.depth >= 1000 && obj.depth <= 1100)
  .sort((a, b) => a.depth - b.depth)
  .forEach(obj => {
    console.log(\`Depth \${obj.depth}: \${obj.type} (\${obj.texture?.key || 'no texture'})\`);
  });`);
        }

        function runTextureCheck() {
            eval(`const scene = window.gameScene;
if (!scene) {
  console.error('Game scene not found!');
  return;
}

console.log('Texture exists:', scene.textures.exists('hero-sprite'));

if (!scene.partyMemberSprites) {
  console.error('Party member sprites not found!');
  return;
}

scene.partyMemberSprites.forEach((pm, i) => {
  const sprite = pm.sprite;
  if (!sprite) {
    console.log(\`Hero \${i}: NO SPRITE\`);
    return;
  }
  const tint = sprite.tintTopLeft || sprite.tint || 0;
  const tintHex = '0x' + tint.toString(16).padStart(6, '0').toUpperCase();
  const isWhite = tint === 0xFFFFFF || tint === 16777215;
  
  console.log(\`Hero \${i} (\${pm.hero?.id || 'unknown'}):\`, {
    texture: sprite.texture?.key || 'N/A',
    tint: tintHex + (isWhite ? ' ⚠️ WHITE!' : ''),
    alpha: sprite.alpha,
    scaleX: sprite.scaleX,
    scaleY: sprite.scaleY,
    visible: sprite.visible,
    active: sprite.active
  });
});`);
        }

        function clearAllTints() {
            const scene = getGameScene();
            if (!scene) return;

            scene.partyMemberSprites?.forEach(pm => {
                if (pm.sprite) {
                    pm.sprite.clearTint();
                }
            });
            
            console.log('Cleared all hero tints');
            alert('All hero tints cleared!');
        }

        function runCameraCheck() {
            eval(`const scene = window.gameScene;
if (!scene) {
  console.error('Game scene not found!');
  return;
}

const camera = scene.cameras.main;
console.log('=== Camera State ===');
console.log('Follow target:', camera.followTarget);
console.log('Camera position:', { 
  scrollX: camera.scrollX, 
  scrollY: camera.scrollY,
  width: camera.width,
  height: camera.height
});
console.log('Follow offset:', camera.followOffset);

if (scene.partyMemberSprites && scene.partyMemberSprites.length > 0) {
  const positions = scene.partyMemberSprites.map(pm => ({
    x: pm.sprite?.x || 0,
    y: pm.sprite?.y || 0,
    id: pm.hero?.id || 'unknown'
  }));
  
  const minX = Math.min(...positions.map(p => p.x));
  const maxX = Math.max(...positions.map(p => p.x));
  const minY = Math.min(...positions.map(p => p.y));
  const maxY = Math.max(...positions.map(p => p.y));
  const centerX = (minX + maxX) / 2;
  const centerY = (minY + maxY) / 2;
  
  console.log('\\n=== Party Bounds ===');
  console.log('Min X:', minX, 'Max X:', maxX);
  console.log('Min Y:', minY, 'Max Y:', maxY);
  console.log('Center:', { x: centerX, y: centerY });
  console.log('Camera center should be at:', centerX);
  console.log('Camera is actually at:', camera.scrollX + camera.width / 2);
  console.log('Difference:', Math.abs((camera.scrollX + camera.width / 2) - centerX));
}`);        }

        function runUpdateCheck() {
            eval(`const scene = window.gameScene;
if (!scene || !scene.partyMemberSprites) {
  console.error('Game scene or party sprites not found!');
  return;
}

console.log('Monitoring visibility over 10 checks (every 50ms)...');
let count = 0;
const interval = setInterval(() => {
  console.log(\`\\n=== Check \${count + 1} ===\`);
  scene.partyMemberSprites.forEach((pm, i) => {
    const sprite = pm.sprite;
    if (!sprite) {
      console.log(\`  Hero \${i}: NO SPRITE\`);
      return;
    }
    console.log(\`  Hero \${i} (\${pm.hero?.id || 'unknown'}):\`, {
      visible: sprite.visible ? '✓' : '✗',
      active: sprite.active ? '✓' : '✗',
      alpha: sprite.alpha
    });
  });
  count++;
  if (count >= 10) {
    clearInterval(interval);
    console.log('\\nMonitoring complete.');
  }
}, 50);`);
        }

        function runAnimationCheck() {
            eval(`const scene = window.gameScene;
if (!scene || !scene.partyMemberSprites) {
  console.error('Game scene or party sprites not found!');
  return;
}

scene.partyMemberSprites.forEach((pm, i) => {
  const hero = pm.hero;
  if (!hero) {
    console.log(\`Hero \${i}: NO HERO DATA\`);
    return;
  }
  
  const characterType = (hero.classId || 'paladin').toLowerCase();
  const characterId = hero.id || \`hero_\${i}\`;
  const idleKey = \`\${characterType}-\${characterId}-idle\`;
  const walkKey = \`\${characterType}-\${characterId}-walk\`;
  
  console.log(\`Hero \${i} (\${hero.id}):\`, {
    class: characterType,
    idleAnimation: scene.anims.exists(idleKey) ? '✓ EXISTS' : '✗ MISSING',
    walkAnimation: scene.anims.exists(walkKey) ? '✓ EXISTS' : '✗ MISSING',
    currentAnimation: pm.sprite?.anims?.currentAnim?.key || 'NONE'
  });
});

console.log('\\n=== All Available Animations ===');
const allAnims = scene.anims.anims.entries;
Object.keys(allAnims).filter(k => k.includes('hero')).forEach(key => {
  console.log(\`  \${key}\`);
});`);
        }
    </script>
</body>
</html>

