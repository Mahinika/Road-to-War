extends Node

func _get_logger():
	return get_node_or_null("/root/Logger")

func _log_info(source: String, message: String):
	var logger = _get_logger()
	if logger:
		logger.info(source, message)
	else:
		print("[%s] [INFO] %s" % [source, message])

func _log_warn(source: String, message: String):
	var logger = _get_logger()
	if logger:
		logger.warn(source, message)
	else:
		print("[%s] [WARN] %s" % [source, message])

func _log_error(source: String, message: String):
	var logger = _get_logger()
	if logger:
		logger.error(source, message)
	else:
		print("[%s] [ERROR] %s" % [source, message])

func _log_debug(source: String, message: String):
	var logger = _get_logger()
	if logger:
		logger.debug(source, message)
	else:
		print("[%s] [DEBUG] %s" % [source, message])

# ResourceManager.gd - Handles mana, energy, and consumable resources
# Manages regeneration, consumption, and strategic resource allocation

signal resource_updated(hero_id, resource_type, current, max_value)
signal consumable_used(hero_id, item_id, effects)

var hero_resources: Dictionary = {} # hero_id -> { mana, max_mana, energy, max_energy, rage, max_rage }
var consumables: Dictionary = {} # item_id -> { count: int, effects: Dictionary }

var current_strategy: String = "passive"

func _ready():
	_log_info("ResourceManager", "Initialized")
	var cm = get_node_or_null("/root/CombatManager")
	if cm:
		if not cm.damage_dealt.is_connected(_on_damage_dealt):
			cm.damage_dealt.connect(_on_damage_dealt)

func initialize_hero_resources(hero_id: String):
	var pm = get_node_or_null("/root/PartyManager")
	var hero = pm.get_hero_by_id(hero_id) if pm else null
	var max_mana = 100
	var max_energy = 100
	var max_rage = 100
	
	if hero:
		var stats = hero.current_stats
		if stats.has("intellect"):
			max_mana = 100 + (stats["intellect"] * 15)
	
	hero_resources[hero_id] = {
		"mana": max_mana,
		"max_mana": max_mana,
		"energy": max_energy,
		"max_energy": max_energy,
		"rage": 0.0,
		"max_rage": max_rage
	}

func get_resource_type(hero_id: String) -> String:
	var pm = get_node_or_null("/root/PartyManager")
	var hero = pm.get_hero_by_id(hero_id) if pm else null
	if not hero: return "mana"
	
	match hero.class_id:
		"warrior": return "rage"
		"rogue": return "energy"
		_: return "mana"

func update_resources(delta: float):
	for hero_id in hero_resources:
		regenerate_resources(hero_id, delta)

func regenerate_resources(hero_id: String, delta: float):
	if not hero_resources.has(hero_id):
		return
	
	var pm = get_node_or_null("/root/PartyManager")
	var hero = pm.get_hero_by_id(hero_id) if pm else null
	if not hero: return

	var resources = hero_resources[hero_id]
	var multiplier = get_regeneration_multiplier(current_strategy)
	
	# Declare combat state variables at function level to avoid shadowing warnings
	var combat_mgr = get_node_or_null("/root/CombatManager")
	var hero_in_combat = combat_mgr.in_combat if combat_mgr else false
	
	# 1. Health regeneration (Passive)
	var max_hp = hero.current_stats.get("maxHealth", 100)
	var current_hp = hero.current_stats.get("health", 0)
	if current_hp < max_hp:
		# Base regen: 2% of max HP per second outside combat, 0.5% in combat
		var regen_percent = 0.02 if not hero_in_combat else 0.005
		var hp_regen = max_hp * regen_percent * multiplier * delta
		
		# Minimum 1 HP regen per second if below max
		hp_regen = max(hp_regen, 1.0 * delta)
		
		hero.current_stats["health"] = min(max_hp, current_hp + hp_regen)
	
	# 2. Mana regeneration
	if resources.mana < resources.max_mana:
		var mana_regen = 8 * multiplier * delta # Increased base mana per second
		resources.mana = min(resources.max_mana, resources.mana + mana_regen)
		resource_updated.emit(hero_id, "mana", resources.mana, resources.max_mana)
	
	# 3. Energy regeneration
	if resources.energy < resources.max_energy:
		var energy_regen = 10 * multiplier * delta # Increased base energy per second
		resources.energy = min(resources.max_energy, resources.energy + energy_regen)
		resource_updated.emit(hero_id, "energy", resources.energy, resources.max_energy)
	
	# 4. Rage behavior (Warrior)
	# Rage is generated by dealing/taking damage (see _on_damage_dealt).
	# Out of combat it decays toward 0 for readability.
	if get_resource_type(hero_id) == "rage":
		var current_rage: float = float(resources.get("rage", 0.0))
		var max_rage: float = float(resources.get("max_rage", 100.0))
		var decay_rate = 6.0 if hero_in_combat else 18.0 # rage per second
		var new_rage = max(0.0, current_rage - (decay_rate * delta))
		if new_rage != current_rage:
			resources["rage"] = new_rage
			resource_updated.emit(hero_id, "rage", new_rage, max_rage)

func consume_resource(hero_id: String, resource_type: String, amount: float) -> bool:
	if not hero_resources.has(hero_id):
		return false
	
	var resources = hero_resources[hero_id]
	if not resources.has(resource_type):
		return false
	
	if resources[resource_type] >= amount:
		resources[resource_type] -= amount
		resource_updated.emit(hero_id, resource_type, resources[resource_type], resources["max_" + resource_type])
		return true
	
	return false

func get_resource(hero_id: String, resource_type: String) -> float:
	if hero_resources.has(hero_id):
		return hero_resources[hero_id].get(resource_type, 0.0)
	return 0.0

func add_resource(hero_id: String, resource_type: String, amount: float) -> void:
	if not hero_resources.has(hero_id):
		return
	var resources = hero_resources[hero_id]
	var max_key = "max_" + resource_type
	var max_value: float = float(resources.get(max_key, 100.0))
	var current: float = float(resources.get(resource_type, 0.0))
	var next_val = clampf(current + amount, 0.0, max_value)
	if next_val != current:
		resources[resource_type] = next_val
		resource_updated.emit(hero_id, resource_type, next_val, max_value)

func _on_damage_dealt(source_id: String, target_id: String, amount: int, _is_crit: bool) -> void:
	# Rage generation (simple model):
	# - Warrior gains rage on dealing damage and on taking damage.
	# This is intentionally lightweight (RuneScape-like readability).
	var pm = get_node_or_null("/root/PartyManager")
	if not pm:
		return
	var source_hero = pm.get_hero_by_id(source_id)
	if source_hero and source_hero.class_id == "warrior":
		add_resource(source_id, "rage", 2.0 + (float(amount) * 0.05))
	var target_hero = pm.get_hero_by_id(target_id)
	if target_hero and target_hero.class_id == "warrior":
		add_resource(target_id, "rage", 1.0 + (float(amount) * 0.10))

func add_consumable(item_id: String, count: int = 1, effects: Dictionary = {}):
	if consumables.has(item_id):
		consumables[item_id].count += count
	else:
		consumables[item_id] = { "count": count, "effects": effects }

func use_consumable(hero_id: String, item_id: String) -> bool:
	if not consumables.has(item_id) or consumables[item_id].count <= 0:
		return false
	
	var effects = consumables[item_id].effects
	consumables[item_id].count -= 1
	
	apply_consumable_effects(hero_id, effects)
	consumable_used.emit(hero_id, item_id, effects)
	
	_log_info("ResourceManager", "Used consumable %s for hero %s" % [item_id, hero_id])
	return true

func apply_consumable_effects(hero_id: String, effects: Dictionary):
	for effect_type in effects:
		match effect_type:
			"restore_mana":
				var amount = effects[effect_type]
				if hero_resources.has(hero_id):
					var resources = hero_resources[hero_id]
					resources.mana = min(resources.max_mana, resources.mana + amount)
					resource_updated.emit(hero_id, "mana", resources.mana, resources.max_mana)
			
			"restore_health":
				var pm = get_node_or_null("/root/PartyManager")
				var hero = pm.get_hero_by_id(hero_id) if pm else null
				if hero:
					var amount = effects[effect_type]
					hero.current_stats.health = min(hero.current_stats.maxHealth, hero.current_stats.health + amount)

func get_consumable_count(item_id: String) -> int:
	if consumables.has(item_id):
		return consumables[item_id].count
	return 0

func get_regeneration_multiplier(strategy: String) -> float:
	match strategy:
		"passive":
			return 1.0
		"active":
			return 1.5
		"burst":
			return 2.0
		_:
			return 1.0

func set_regeneration_strategy(strategy: String):
	current_strategy = strategy
	_log_info("ResourceManager", "Regeneration strategy set to: %s" % strategy)

func get_save_data() -> Dictionary:
	return {
		"hero_resources": hero_resources,
		"consumables": consumables,
		"current_strategy": current_strategy
	}

func load_save_data(save_data: Dictionary):
	hero_resources = save_data.get("hero_resources", {})
	consumables = save_data.get("consumables", {})
	current_strategy = save_data.get("current_strategy", "passive")
